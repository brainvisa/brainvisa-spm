# -*- coding: utf-8 -*-
from soma.spm.virtual_spm.util.deformations.composition import Composition as Composition_virtual
from soma.spm.virtual_spm.util.deformations.composition import MatFileImported as MatFileImported_virtual
from soma.spm.virtual_spm.util.deformations.composition import DartelFlow as DartelFlow_virtual
from soma.spm.virtual_spm.util.deformations.composition import DeformationField as DeformationField_virtual
from soma.spm.virtual_spm.util.deformations.composition import IdentityFromImage as IdentityFromImage_virtual
from soma.spm.virtual_spm.util.deformations.composition import Identity as Identity_virtual
from soma.spm.virtual_spm.util.deformations.composition import Inverse as Inverse_virtual

from soma.spm.custom_decorator_pattern import checkIfArgumentTypeIsAllowed, checkIfArgumentTypeIsStrOrUnicode
from soma.spm.spm_batch_maker_utils import convertlistToSPMString, addBatchKeyWordInEachItem
from soma.spm.spm_container import SPMContainer

import abc
import numpy

class Deformation():
  __metaclass__ = abc.ABCMeta

class Composition(Composition_virtual, SPMContainer, Deformation):
  def __init__(self):
    SPMContainer.__init__(self, Deformation)
#===============================================================================
# 
#===============================================================================
class MatFileImported(MatFileImported_virtual, Deformation):
  def __init__(self):
    self.parameter_file_path = None
    self.voxel_size = ["NaN", "NaN", "NaN"]
    self.bounding_box = numpy.array([["NaN", "NaN", "NaN"],["NaN", "NaN", "NaN"]])
#===============================================================================
# 
#===============================================================================
class DartelFlow(DartelFlow_virtual, Deformation):
  def __init__(self):
    self.flow_field_path = None
    self.flow_direction = [1, 0]
    self.time_step = 6
    self.dartel_template_path = ''
    
  @checkIfArgumentTypeIsStrOrUnicode(argument_index=1)
  def setDartelTemplatePath(self, final_dartel_template_path):
    """
    Select  the  final Template file generated by Dartel. This will be affine registered with
    a  TPM  file, such that the resulting spatially normalised images are closer aligned to
    MNI space. Leave empty if you do not wish to incorporate a transform to MNI space.
    """
    self.dartel_template_path = final_dartel_template_path
    
  def getStringListForBatch( self ):
    if self.flow_field_path is not None:
      batch_list = []
      batch_list.append("dartel.flowfield = {'%s'};" %self.flow_field_path)
      batch_list.append("dartel.times = %s;" %convertlistToSPMString(self.flow_direction))
      batch_list.append("dartel.K = %s;" %self.time_step)
      batch_list.append("dartel.template = {'%s'};" %self.dartel_template_path)
      return batch_list
    else:
      raise ValueError("flow field path is required")
#===============================================================================
# 
#===============================================================================
class DeformationField(DeformationField_virtual, Deformation):
  def __init__(self):
    self.deformation_field_path = None
#===============================================================================
# 
#===============================================================================
class IdentityFromImage(IdentityFromImage_virtual, Deformation):
  def __init__(self):
    self.reference_image_path = None
#===============================================================================
# 
#===============================================================================
class Identity(Identity_virtual, Deformation):
  def __init__(self):
    self.voxel_size = ["NaN", "NaN", "NaN"]
    self.bounding_box = numpy.array([["NaN", "NaN", "NaN"],["NaN", "NaN", "NaN"]])
#===============================================================================
# 
#===============================================================================
class Inverse(Inverse_virtual, Deformation):
  def __init__(self):
    self.composition = None
    self.reference_image_path = None
    
  @checkIfArgumentTypeIsAllowed(Composition, 1)
  def setDeformationComposition(self, composition):
    super(Inverse, self).setDeformationComposition(composition)
    
  def getStringListForBatch( self ):
    if not None in [self.composition, self.reference_image_path]:
      batch_list = []
      batch_list.extend(addBatchKeyWordInEachItem("inv", self.composition.getStringListForBatch()))
      batch_list.append("inv.space = {'%s'};" %self.reference_image_path)
      return batch_list
    else:
      raise ValueError("voxel size and bounding box are mandatory")
    