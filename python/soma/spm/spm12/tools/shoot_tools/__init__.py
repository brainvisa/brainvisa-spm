from soma.spm.spm_main_module import SPM12MainModule
from soma.spm.spm_batch_maker_utils import moveSPMPath, convertlistToSPMString, convertNumpyArrayToSPMString, convertPathListToSPMBatchString
from soma.spm.custom_decorator_pattern import checkIfArgumentTypeIsAllowed, checkIfArgumentTypeIsStrOrUnicode
import numpy


class RunShoot(SPM12MainModule):
    def __init__(self):
        self.images_path_list = None
        self.templates_path_list = None
        
        self.jacobian_output_path_list = None
        self.velocity_output_path_list = None
        self.deformation_output_path_list = None
        
    def getStringListForBatch(self):
        if self.images_path_list is not None: 
            images_path_list_for_batch = [] 
            for tissue_images_path_list in self.images_path_list:
                tissues_path_list = ["'%s,1'" % t for t in tissue_images_path_list]
                images_path_list_for_batch.append('\n'.join(tissues_path_list))
            images_path_batch = '\n'.join(['{\n%s\n}' % i for i in images_path_list_for_batch])
            
            templates_path_batch = '\n'.join("'%s'" % temp for temp in self.templates_path_list)
            
            batch_list = []
            batch_list.append("spm.tools.shoot.warp1.images = {%s};" % images_path_batch)
            batch_list.append("spm.tools.shoot.warp1.templates = {%s};" % templates_path_batch)
            return batch_list
        else:
            raise ValueError('At least one image path is required')
    
    def _moveSPMDefaultPathsIfNeeded(self):
        if self.jacobian_output_path_list:
            self._move_output_default_path(self.jacobian_output_path_list, 'j_')
        if self.velocity_output_path_list:
            self._move_output_default_path(self.velocity_output_path_list, 'v_')
        if self.deformation_output_path_list:
            self._move_output_default_path(self.deformation_output_path_list, 'y_')
    
    def _move_output_default_path(self, output_list, output_prefix):
        if output_list is not None:
            if len(output_list) == len(self.images_path_list[0]):
                
                for src, dest in zip(self.images_path_list[0], output_list):
                    moveSPMPath(src, dest,
                                prefix=output_prefix,
                                suffix='_Template')
            else:
                raise ValueError("output_list has not the same length than images_path_list")


class WriteNormalised(SPM12MainModule):
    """
    Normally, Shoot generates deformations that align with the average shaped
    template. This routine includes the option to incorporate an affine
    regisration of the template (the final one generated by Shoot), with the
    TPM data released with SPM.
    "Smoothed (blurred) spatially normalised images are generated in such a way
    that the original signal is preserved as well as possible. Note that
    trilinear interpolation is used, and no masking is done. It is therefore
    essantial that an fMRI/PET time series are realigned and resliced before
    they are spatially normalised. Alternatively, contrast images generated
    from unsmoothed native-space fMRI/PET data can be spatially normalised
    for a 2nd level analysis.
    Two "preserve" options are provided. One of them should do the equavalent of
    generating smoothed "modulated" spatially normalised images. The other does
    the equivalent of smoothing the modulated normalised fMRI/PET, and dividing
    by the smoothed Jacobian determinants.
    """
    def __init__(self):
        self.final_template_path = ''
        self.according_to = None
        self.voxel_sizes = ['NaN', 'NaN', 'NaN']
        self.bounding_box = numpy.array([['NaN', 'NaN', 'NaN'],['NaN', 'NaN', 'NaN']])
        self.preserve = 0
        self.fwhm = 0
        self.deformation_field_path = None
        self.images_path_list = None
        self.output_images_path_list = None
    
    @checkIfArgumentTypeIsStrOrUnicode(argument_index=1)
    def setFinalTemplatePath(self, final_template_path):
        """
        Select the final Template file generated by Shoot. This will be affine
        registered with a TPM file, such that the resulting spatially normalised
        images are closer aligned to MNI space. Leave empty if you do not wish
        to incorporate a transform to MNI space.
        """
        self.final_template_path = final_template_path

    @checkIfArgumentTypeIsAllowed(list, 1)
    def setVoxelSizes(self, voxel_sizes_list):
        """
        Specify the voxel sizes for the warped images. Non-finite values
        will default to the voxel sizes of the template image that was
        originally used to estimate the deformation.
        """
        if len(voxel_sizes_list) == 3:
            self.voxel_sizes = voxel_sizes_list
        else:
            raise ValueError("voxel_sizes_list must have 3 items [x, y, z]")

    @checkIfArgumentTypeIsAllowed(numpy.ndarray, 1)
    def setBoundingBox(self, numpy_array):
        """
        Specify the bounding box for the warped images. Non-finite values
        will default to the bounding box of the template image that was
        originally used to estimate the deformation.
        """
        if numpy_array.shape == (2, 3):
            self.bounding_box = numpy_array
        else:
            raise ValueError("An 2-by-3 array must be entered")

    def setPreserveToConcentrations(self):
        """
        Spatially normalised images are not "modulated".
        The warped images preserve the intensities of the original images.
        """
        self.preserve = 0

    def setPreserveToAmount(self):
        """
        Spatially normalised images are "modulated" in order to preserve
        the total amount of signal in the images. Areas that are expanded
        during warping are correspondingly reduced in intensity.
        """
        self.preserve = 1

    def setFWHM(self, fwhm):
        """
        Specify the full-width at half maximum (FWHM) of the isotropic
        Gaussian blurring kernel in mm.
        """
        self.fwhm = fwhm
    
    @checkIfArgumentTypeIsStrOrUnicode(argument_index=1)
    def setDeformationFieldPath(self, deformation_field_path):
        """
        Select the deformation field generated by Shoot).
        """
        self.deformation_field_path = deformation_field_path
    
    @checkIfArgumentTypeIsAllowed(list, 1)
    def setImagesPathList(self, images_path_list):
        """
        The deformation can be applied to multiple images.
        Select images to spatially normalise.
        """
        self.images_path_list = images_path_list

    @checkIfArgumentTypeIsAllowed(list, 1)
    def setOutputImagesPathList(self, output_images_path_list):
        self.output_images_path_list = output_images_path_list

    def getStringListForBatch(self):
        if not None in [self.deformation_field_path, self.images_path_list]:
            batch_list = []
            #input files
            batch_list.append("spm.tools.shoot.norm.template = {'%s'};" % self.final_template_path)
            batch_list.append("spm.tools.shoot.norm.data.subj.deformation = {'%s'};" % self.deformation_field_path)
            batch_list.append("spm.tools.shoot.norm.data.subj.images = {%s};"
                              % convertPathListToSPMBatchString(self.images_path_list, add_dimension=False))
            #options
            batch_list.append("spm.tools.shoot.norm.vox = %s;" %convertlistToSPMString(self.voxel_sizes))
            batch_list.append("spm.tools.shoot.norm.bb = %s;" %convertNumpyArrayToSPMString(self.bounding_box))
            batch_list.append("spm.tools.shoot.norm.preserve = %i;" %self.preserve)
            batch_list.append("spm.tools.shoot.norm.fwhm = %s;" %self.fwhm)
            return batch_list
        else:
            raise ValueError("deformation_field_path and images_path_list are required")

    def _moveSPMDefaultPathsIfNeeded(self):
        """
        Rename and move the output images if asked otherwise default spm outputs will not move.
        """
        smoothing = (self.fwhm != 0)
        if self.output_images_path_list:
            for image_path, output_image_path in zip(self.images_path_list, self.output_images_path_list):
                if smoothing and self.preserve:
                    prefix = "smw"
                elif smoothing and not self.preserve:
                    prefix = "sw"
                elif self.preserve:
                    prefix = "mw"
                else:
                    prefix = "w"
                moveSPMPath(image_path,
                            output_image_path,
                            prefix=prefix)
