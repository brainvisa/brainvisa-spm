# -*- coding: utf-8 -*-

from __future__ import absolute_import
from soma.spm.custom_decorator_pattern import checkIfArgumentTypeIsAllowed, checkIfArgumentTypeIsStrOrUnicode
from soma.spm.spm_batch_maker_utils import moveSPMPath, convertlistToSPMString
from six.moves import range
from six.moves import zip

class Tissue(object):
  """
  A  number  of  options are available for each of the tissues.  You may wish to save images
  of  some tissues, but not others. If planning to use DARTEL, then make sure you generate
  ``imported''  tissue class images of grey and white matter (and possibly others).  Different
  numbers  of  Gaussians  may be needed to model the intensity distributions of the various
  tissues.
  """
  @checkIfArgumentTypeIsStrOrUnicode(argument_index=1)
  def setTissueProbilityMapPath(self, tissue_probility_map_path):
    """
    Select  the  tissue  probability  image  for  this class. These should be maps of eg
    grey   matter,   white   matter   or  cerebro-spinal  fluid  probability.  A  nonlinear
    deformation  field  is  estimated that best overlays the tissue probability maps on
    the  individual  subjects'  image.  The default tissue probability maps are modified
    versions  of  the  ICBM  Tissue Probabilistic Atlases.These tissue probability maps
    are  kindly  provided  by  the  International Consortium for Brain Mapping, John C.
    Mazziotta and Arthur W. Toga.
    http://www.loni.ucla.edu/ICBM/ICBM_TissueProb.html.   The   original   data   are
    derived  from  452  T1-weighted  scans,  which  were aligned with an atlas space,
    corrected  for scan inhomogeneities, and classified into grey matter, white matter
    and  cerebrospinal  fluid.  These data were then affine registered to the MNI space
    and down-sampled to 2mm resolution.
    Rather   than   assuming   stationary   prior   probabilities   based   upon   mixing
    proportions,   additional   information  is  used,  based  on  other  subjects'  brain
    images.    Priors  are  usually  generated by registering a large number of subjects
    together,  assigning  voxels to different tissue types and averaging tissue classes
    over  subjects.  Three  tissue  classes  are  used:  grey  matter,  white matter and
    cerebro-spinal  fluid.  A  fourth  class is also used, which is simply one minus the
    sum  of  the  first  three.  These  maps give the prior probability of any voxel in a
    registered image being of any of the tissue classes - irrespective of its intensity.
    The  model  is  refined  further  by  allowing  the  tissue  probability  maps  to  be
    deformed   according   to  a  set  of  estimated  parameters.  This  allows  spatial
    normalisation and segmentation to be combined into the same model.
    """
    self.tissue_probility_map_path = tissue_probility_map_path

  @checkIfArgumentTypeIsAllowed(int, 1)
  def setTissueProbilityDimension(self, tissue_probility_map_dimension_number):
    self.tissue_probility_map_dimension_number = tissue_probility_map_dimension_number

  @checkIfArgumentTypeIsAllowed(int, 1)
  def setGaussianNumber(self, gaussian_number):
    """
    The  number  of  Gaussians  used  to represent the intensity distribution for each
    tissue class can be greater than one. In other words, a tissue probability map may
    be  shared  by  several  clusters. The assumption of a single Gaussian distribution
    for  each  class  does not hold for a number of reasons. In particular, a voxel may
    not  be  purely  of  one  tissue  type, and instead contain signal from a number of
    different  tissues (partial volume effects). Some partial volume voxels could fall at
    the   interface   between  different  classes,  or  they  may  fall  in  the  middle  of
    structures such as the thalamus, which may be considered as being either grey or
    white   matter.   Various  other  image  segmentation  approaches  use  additional
    clusters to model such partial volume effects. These generally assume that a pure
    tissue  class has a Gaussian intensity distribution, whereas intensity distributions
    for  partial  volume  voxels are broader, falling between the intensities of the pure
    classes. Unlike these partial volume segmentation approaches, the model adopted
    here  simply  assumes  that  the  intensity  distribution  of each class may not be
    Gaussian,  and  assigns  belonging  probabilities according to these non-Gaussian
    distributions. Typical numbers of Gaussians could be two for grey matter, two for
    white  matter, two for CSF, three for bone, four for other soft tissues and two for
    air (background).
    Note   that  if  any  of  the  Num.  Gaussians  is  set  to  non-parametric,  then  a
    non-parametric  approach  will  be  used to model the tissue intensities. This may
    work for some images (eg CT), but not others - and it has not been optimised for
    multi-channel  data.  Note  that it is likely to be especially problematic for images
    with  poorly  behaved  intensity histograms due to aliasing effects that arise from
    having discrete values on the images.
    """
    if gaussian_number in range(1,9):
      self.gaussian_number = str(gaussian_number)
    else:
      raise ValueError('Gaussian number must be between 1 and 8')

  def unsetGaussian(self):
    self.gaussian_number = 'Inf'

  def setNativeTissueNativeSpace(self):
    """
    The  native space option allows you to produce a tissue class image (c*) that is in
    alignment  with  the original. It can also be used for ``importing'' into a form that
    can be used with the DARTEL toolbox (rc*).
    """
    self.native_tissue = [1, 0]

  def setNativeTissueDARTELImported(self):
    """
    The  native space option allows you to produce a tissue class image (c*) that is in
    alignment  with  the original. It can also be used for ``importing'' into a form that
    can be used with the DARTEL toolbox (rc*).
    """
    self.native_tissue = [0, 1]

  def setNativeTissueNativeSpaceAndDARTELImported(self):
    """
    The  native space option allows you to produce a tissue class image (c*) that is in
    alignment  with  the original. It can also be used for ``importing'' into a form that
    can be used with the DARTEL toolbox (rc*).
    """
    self.native_tissue = [1, 1]

  def unsetNativeTissue(self):
    """
    The  native space option allows you to produce a tissue class image (c*) that is in
    alignment  with  the original. It can also be used for ``importing'' into a form that
    can be used with the DARTEL toolbox (rc*).
    """
    self.native_tissue = [0, 0]

  def setWarpedTissueModulated(self):
    """
    You  can  produce  spatially  normalised  versions  of the tissue class - both with
    (mwc*)   and   without  (wc*)  modulation  (see  below).  These  can  be  used  for
    voxel-based morphometry. All you need to do is smooth them and do the stats.
    ``Modulation''  is  to  compensate  for  the  effect  of spatial normalisation.  When
      warping  a  series of images to match a template, it is inevitable that volumetric
      differences  will  be  introduced  into  the  warped  images.   For example, if one
      subject's  temporal  lobe  has  half  the  volume of that of the template, then its
      volume  will  be  doubled  during  spatial  normalisation. This will also result in a
      doubling  of  the  voxels labelled grey matter.  In order to remove this confound,
      the  spatially  normalised  grey  matter  (or  other  tissue  class)  is  adjusted by
      multiplying by its relative volume before and after warping.  If warping results in
      a  region  doubling  its volume, then the correction will halve the intensity of the
      tissue  label. This whole procedure has the effect of preserving the total amount
      of  grey  matter  signal  in the normalised partitions.  Actually, in this version of
      SPM   the   warped  data  are  not  scaled  by  the  Jacobian  determinants  when
      generating  the "modulated" data.  Instead, the original voxels are projected into
      their  new  location  in  the  warped  images.    This exactly preserves the tissue
      count,  but  has  the  effect  of  introducing  aliasing  artifacts - especially if the
      original  data  are  at  a  lower  resolution  than  the warped images.  Smoothing
      should reduce this artifact though.
      Note  also  that  the  "unmodulated"  data are generated slightly differently in this
      version  of  SPM.  In  this version, the projected data are corrected using a kind of
      smoothing  procedure.  This  is  not  done  exactly  as  it should be done (to save
      computational  time),  but  it  does  a  reasonable  job.  It  also  has  the effect of
      extrapolating  the  warped  tissue  class  images  beyond the range of the original
      data.    This  extrapolation is not perfect, as it is only an estimate, but it may still
      be a good thing to do.
    """
    self.warped_tissue = [0, 1]

  def setWarpedTissueUnmodulated(self):
    """
    You  can  produce  spatially  normalised  versions  of the tissue class - both with
    (mwc*)   and   without  (wc*)  modulation  (see  below).  These  can  be  used  for
    voxel-based morphometry. All you need to do is smooth them and do the stats.
    ``Modulation''  is  to  compensate  for  the  effect  of spatial normalisation.  When
      warping  a  series of images to match a template, it is inevitable that volumetric
      differences  will  be  introduced  into  the  warped  images.   For example, if one
      subject's  temporal  lobe  has  half  the  volume of that of the template, then its
      volume  will  be  doubled  during  spatial  normalisation. This will also result in a
      doubling  of  the  voxels labelled grey matter.  In order to remove this confound,
      the  spatially  normalised  grey  matter  (or  other  tissue  class)  is  adjusted by
      multiplying by its relative volume before and after warping.  If warping results in
      a  region  doubling  its volume, then the correction will halve the intensity of the
      tissue  label. This whole procedure has the effect of preserving the total amount
      of  grey  matter  signal  in the normalised partitions.  Actually, in this version of
      SPM   the   warped  data  are  not  scaled  by  the  Jacobian  determinants  when
      generating  the "modulated" data.  Instead, the original voxels are projected into
      their  new  location  in  the  warped  images.    This exactly preserves the tissue
      count,  but  has  the  effect  of  introducing  aliasing  artifacts - especially if the
      original  data  are  at  a  lower  resolution  than  the warped images.  Smoothing
      should reduce this artifact though.
      Note  also  that  the  "unmodulated"  data are generated slightly differently in this
      version  of  SPM.  In  this version, the projected data are corrected using a kind of
      smoothing  procedure.  This  is  not  done  exactly  as  it should be done (to save
      computational  time),  but  it  does  a  reasonable  job.  It  also  has  the effect of
      extrapolating  the  warped  tissue  class  images  beyond the range of the original
      data.    This  extrapolation is not perfect, as it is only an estimate, but it may still
      be a good thing to do.
    """
    self.warped_tissue = [1, 0]

  def setWarpedTissueModulatedAndUnmodulated(self):
    """
    You  can  produce  spatially  normalised  versions  of the tissue class - both with
    (mwc*)   and   without  (wc*)  modulation  (see  below).  These  can  be  used  for
    voxel-based morphometry. All you need to do is smooth them and do the stats.
    ``Modulation''  is  to  compensate  for  the  effect  of spatial normalisation.  When
      warping  a  series of images to match a template, it is inevitable that volumetric
      differences  will  be  introduced  into  the  warped  images.   For example, if one
      subject's  temporal  lobe  has  half  the  volume of that of the template, then its
      volume  will  be  doubled  during  spatial  normalisation. This will also result in a
      doubling  of  the  voxels labelled grey matter.  In order to remove this confound,
      the  spatially  normalised  grey  matter  (or  other  tissue  class)  is  adjusted by
      multiplying by its relative volume before and after warping.  If warping results in
      a  region  doubling  its volume, then the correction will halve the intensity of the
      tissue  label. This whole procedure has the effect of preserving the total amount
      of  grey  matter  signal  in the normalised partitions.  Actually, in this version of
      SPM   the   warped  data  are  not  scaled  by  the  Jacobian  determinants  when
      generating  the "modulated" data.  Instead, the original voxels are projected into
      their  new  location  in  the  warped  images.    This exactly preserves the tissue
      count,  but  has  the  effect  of  introducing  aliasing  artifacts - especially if the
      original  data  are  at  a  lower  resolution  than  the warped images.  Smoothing
      should reduce this artifact though.
      Note  also  that  the  "unmodulated"  data are generated slightly differently in this
      version  of  SPM.  In  this version, the projected data are corrected using a kind of
      smoothing  procedure.  This  is  not  done  exactly  as  it should be done (to save
      computational  time),  but  it  does  a  reasonable  job.  It  also  has  the effect of
      extrapolating  the  warped  tissue  class  images  beyond the range of the original
      data.    This  extrapolation is not perfect, as it is only an estimate, but it may still
      be a good thing to do.
    """
    self.warped_tissue = [1, 1]

  def unsetWarpedTissue(self):
    """
    You  can  produce  spatially  normalised  versions  of the tissue class - both with
    (mwc*)   and   without  (wc*)  modulation  (see  below).  These  can  be  used  for
    voxel-based morphometry. All you need to do is smooth them and do the stats.
    ``Modulation''  is  to  compensate  for  the  effect  of spatial normalisation.  When
      warping  a  series of images to match a template, it is inevitable that volumetric
      differences  will  be  introduced  into  the  warped  images.   For example, if one
      subject's  temporal  lobe  has  half  the  volume of that of the template, then its
      volume  will  be  doubled  during  spatial  normalisation. This will also result in a
      doubling  of  the  voxels labelled grey matter.  In order to remove this confound,
      the  spatially  normalised  grey  matter  (or  other  tissue  class)  is  adjusted by
      multiplying by its relative volume before and after warping.  If warping results in
      a  region  doubling  its volume, then the correction will halve the intensity of the
      tissue  label. This whole procedure has the effect of preserving the total amount
      of  grey  matter  signal  in the normalised partitions.  Actually, in this version of
      SPM   the   warped  data  are  not  scaled  by  the  Jacobian  determinants  when
      generating  the "modulated" data.  Instead, the original voxels are projected into
      their  new  location  in  the  warped  images.    This exactly preserves the tissue
      count,  but  has  the  effect  of  introducing  aliasing  artifacts - especially if the
      original  data  are  at  a  lower  resolution  than  the warped images.  Smoothing
      should reduce this artifact though.
      Note  also  that  the  "unmodulated"  data are generated slightly differently in this
      version  of  SPM.  In  this version, the projected data are corrected using a kind of
      smoothing  procedure.  This  is  not  done  exactly  as  it should be done (to save
      computational  time),  but  it  does  a  reasonable  job.  It  also  has  the effect of
      extrapolating  the  warped  tissue  class  images  beyond the range of the original
      data.    This  extrapolation is not perfect, as it is only an estimate, but it may still
      be a good thing to do.
    """
    self.warped_tissue = [0, 0]

  @checkIfArgumentTypeIsAllowed(list, 1)
  def setNativeOutputPathList(self, output_path_list):
    self.native_tissue_path_list = output_path_list

  @checkIfArgumentTypeIsAllowed(list, 1)
  def setDartelOutputPathList(self, output_path_list):
    self.dartel_tissue_path_list = output_path_list

  @checkIfArgumentTypeIsAllowed(list, 1)
  def setWarpedModulatedOutputPathList(self, output_path_list):
    self.warped_modulated_tissue_path_list = output_path_list

  @checkIfArgumentTypeIsAllowed(list, 1)
  def setWarpedUnmodulatedOutputPathList(self, output_path_list):
    self.warped_unmodulated_tissue_path_list = output_path_list

  @checkIfArgumentTypeIsAllowed(int, 1)
  def setTissueIndex(self, tissue_index):
    self.tissue_index = tissue_index

  def getStringListForBatch(self):
    if self.tissue_probility_map_path is not None:
      batch_list = []
      batch_list.append("tpm =  {'%s,%i'};" % (self.tissue_probility_map_path,self.tissue_probility_map_dimension_number))
      batch_list.append('ngaus = %s;' % self.gaussian_number)
      batch_list.append('native = %s;' % convertlistToSPMString(self.native_tissue))
      batch_list.append('warped = %s;' % convertlistToSPMString(self.warped_tissue))
      return batch_list
    else:
      raise ValueError('Tissue probability map is required')

  @checkIfArgumentTypeIsAllowed(list, 1)
  def moveIfNeeded(self, volume_path_list):
    if self.native_tissue_path_list:
      for native_tissue_path, volume_path in zip(self.native_tissue_path_list,
                                                 volume_path_list):
        moveSPMPath(volume_path,
                    native_tissue_path,
                    prefix=self.native_tissue_prefix + str(self.tissue_index))
    if self.dartel_tissue_path_list:
      for dartel_tissue_path, volume_path in zip(self.dartel_tissue_path_list,
                                                 volume_path_list):
        moveSPMPath(volume_path,
                    dartel_tissue_path,
                    prefix=self.dartel_tissue_prefix + str(self.tissue_index))
    if self.warped_unmodulated_tissue_path_list:
      for warped_unmodulated_tissue_path, volume_path in zip(self.warped_unmodulated_tissue_path_list,
                                                             volume_path_list):
         moveSPMPath(volume_path,
                     warped_unmodulated_tissue_path,
                     prefix=self.warped_unmodulated_tissue_prefix + str(self.tissue_index))
    if self.warped_modulated_tissue_path_list:
      for warped_modulated_tissue_path, volume_path in zip(self.warped_modulated_tissue_path_list,
                                                           volume_path_list):
         moveSPMPath(volume_path,
                    warped_modulated_tissue_path,
                    prefix=self.warped_modulated_tissue_prefix + str(self.tissue_index))

