# -*- coding: utf-8 -*-
from soma.spm.custom_decorator_pattern import checkIfArgumentTypeIsAllowed
from soma.spm.spm_batch_maker_utils import moveFileAndCreateFoldersIfNeeded

import os

class CreateWarped():
  """
  This  allows  spatially normalised images to be generated. Note that voxel sizes and bounding boxes can not be adjusted, and that there
  may  be  strange  effects  due to the boundary conditions used by the warping. Also note that the warped images are not in Talairach or
  MNI  space.  The coordinate system is that of the average shape and size of the subjects to which DARTEL was applied. In order to have
  MNI-space  normalised  images, then the Deformations Utility can be used to compose the individual DARTEL warps, with a deformation
  field that matches (e.g.) the Template grey matter generated by DARTEL, with one of the grey matter volumes released with SPM.
  """
  @checkIfArgumentTypeIsAllowed(list, 1)
  def setFlowFieldPathList(self, flow_field_path_list):
    """
    The  flow fields store the deformation information. The same fields can be used for both forward or backward deformations (or even, in
    principle, half way or exaggerated deformations).
    """
    self.flow_field_list = flow_field_path_list
    
  @checkIfArgumentTypeIsAllowed(list, 1)
  def setFirstImagePathList(self, image_path_list):
    """
    The  flow  field deformations can be applied to multiple images. At this point, you are choosing how many images each flow field should
    be applied to.
    """
    self.images_list_list.insert(0, image_path_list)
    
  @checkIfArgumentTypeIsAllowed(list, 1)
  def appendImageList(self, image_path_list):
    """
    The  flow  field deformations can be applied to multiple images. At this point, you are choosing how many images each flow field should
    be applied to.
    """
    self.images_list_list.append(image_path_list)
    
  def setModulation(self):
    """
    This  allows  the spatially normalised images to be rescaled by the Jacobian determinants of the deformations. Note that the rescaling is
    only approximate for deformations generated using smaller numbers of time steps.
    """
    self.modulation = 1
    
  def unsetModulation(self):
    """
    This  allows  the spatially normalised images to be rescaled by the Jacobian determinants of the deformations. Note that the rescaling is
    only approximate for deformations generated using smaller numbers of time steps.
    """
    self.modulation = 0
    
  @checkIfArgumentTypeIsAllowed(int, 1)
  def setTimeSteps(self, time_steps):
    """
    The  number  of  time points used for solving the partial differential equations.  A
    single  time  point  would  be  equivalent  to  a  small deformation model. Smaller
    values  allow  faster  computations,  but  are  less  accurate  in  terms  of inverse
    consistency  and  may  result  in the one-to-one mapping breaking down.  Earlier
    iteration  could  use  fewer  time  points,  but  later ones should use about 64 (or
    fewer if the deformations are very smooth).
    """
    if time_steps in [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]:
      #WARNING : For SPM batch, it is the index in this list to write! (but i don't know why SPM do this)
      self.time_steps = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512].index(time_steps)
    else:
      raise ValueError("Unvalid time steps")
    
  def setInterpolationToNearestNeighbour(self):
    """
    The  method  by which the images are sampled when being written in a different space. (Note that Inf or NaN values are treated as zero,
    rather than as missing data)
        Nearest Neighbour:
        - Fastest, but not normally recommended.
    """
    self.interpolation = 0
    
  def setInterpolationToTrilinear(self):
    """
    The  method  by which the images are sampled when being written in a different space. (Note that Inf or NaN values are treated as zero,
    rather than as missing data)
        Trilinear Interpolation:
        - OK for PET, realigned fMRI, or segmentations
    """
    self.interpolation = 1
    
  def setInterpolationTo2ndDegreeBSpline(self):
    """
    The  method  by which the images are sampled when being written in a different space. (Note that Inf or NaN values are treated as zero,
    rather than as missing data)
        B-spline Interpolation:
          - Better  quality  (but  slower) interpolation, especially with higher degree splines. Can produce values outside the original range (e.g.
            small negative values from an originally all positive image).
    """
    self.interpolation = 2
    
  def setInterpolationTo3dDegreeBSpline(self):
    """
    The  method  by which the images are sampled when being written in a different space. (Note that Inf or NaN values are treated as zero,
    rather than as missing data)
        B-spline Interpolation:
          - Better  quality  (but  slower) interpolation, especially with higher degree splines. Can produce values outside the original range (e.g.
            small negative values from an originally all positive image).
    """
    self.interpolation = 3
    
  def setInterpolationTo4thDegreeBSpline(self):
    """
    The  method  by which the images are sampled when being written in a different space. (Note that Inf or NaN values are treated as zero,
    rather than as missing data)
        B-spline Interpolation:
          - Better  quality  (but  slower) interpolation, especially with higher degree splines. Can produce values outside the original range (e.g.
            small negative values from an originally all positive image).
    """
    self.interpolation = 4
    
  def setInterpolationTo5thDegreeBSpline(self):
    """
    The  method  by which the images are sampled when being written in a different space. (Note that Inf or NaN values are treated as zero,
    rather than as missing data)
        B-spline Interpolation:
          - Better  quality  (but  slower) interpolation, especially with higher degree splines. Can produce values outside the original range (e.g.
            small negative values from an originally all positive image).
    """
    self.interpolation = 5
    
  def setInterpolationTo6thDegreeBSpline(self):
    """
    The  method  by which the images are sampled when being written in a different space. (Note that Inf or NaN values are treated as zero,
    rather than as missing data)
        B-spline Interpolation:
          - Better  quality  (but  slower) interpolation, especially with higher degree splines. Can produce values outside the original range (e.g.
            small negative values from an originally all positive image).
    """
    self.interpolation = 6
    
  def setInterpolationTo7thDegreeBSpline(self):
    """
    The  method  by which the images are sampled when being written in a different space. (Note that Inf or NaN values are treated as zero,
    rather than as missing data)
        B-spline Interpolation:
          - Better  quality  (but  slower) interpolation, especially with higher degree splines. Can produce values outside the original range (e.g.
            small negative values from an originally all positive image).
    """
    self.interpolation = 7
    
  def setListOutputWarpedPathList(self, output_warped_path_list_list):
    self.output_warped_path_list_list = output_warped_path_list_list

  def getStringListForBatch( self ):
    if self.images_list_list and self.flow_field_list:
      flow_field_batch =  "{\n"
      for flow_field in self.flow_field_list:
        flow_field_batch += "'%s'\n" %flow_field
      flow_field_batch += "}"
      images_batch = "{\n"
      for images_list in self.images_list_list:
        images_batch += "{\n"
        for images_path in images_list:
          images_batch += "'%s'\n" % images_path
        images_batch += "}\n"
      images_batch += "}'"
      batch_list = []
      batch_list.append("spm.tools.dartel.crt_warped.flowfields = %s;" % flow_field_batch)
      batch_list.append("spm.tools.dartel.crt_warped.images = %s;" % images_batch)
      batch_list.append("spm.tools.dartel.crt_warped.jactransf = %i;" % self.modulation)
      batch_list.append("spm.tools.dartel.crt_warped.K = %i;" % self.time_steps)
      batch_list.append("spm.tools.dartel.crt_warped.interp = %i;" % self.interpolation)
      return batch_list
    else:
      raise ValueError('images_list_list and/or flow_field_list not found')
    
  def _moveSPMDefaultPathsIfNeeded(self):
    #images warped path : <flow_field dir>/w<image_basename>
    if self.modulation:
      spm_prefix = self._modulated_prefix
    else:
      spm_prefix = self._unmodulated_prefix
      
    if self.output_warped_path_list_list is not None:
      if len(self.images_list_list) == len(self.output_warped_path_list_list):
        for images_list, output_warped_path_list in zip(self.images_list_list, self.output_warped_path_list_list):
          if len(images_list) == len(output_warped_path_list) == len(self.flow_field_list):
            for image_path, output_warped_path, flow_field in zip(images_list, output_warped_path_list, self.flow_field_list):
              flow_field_dir = os.path.dirname(flow_field)
              image_basename = os.path.basename(image_path)
              spm_default_output_path = os.path.join(flow_field_dir, spm_prefix + image_basename)
              moveFileAndCreateFoldersIfNeeded(spm_default_output_path, output_warped_path)
          else:
            raise ValueError("images_list length do not coincide with output_warped_path_list length")
      else:
        raise ValueError("images_list_list length do not coincide with output_warped_path_list_list length")
        
    