# -*- coding: utf-8 -*-
"""
Created on Wed Sep 28 11:20:25 2016

@author: ml236783
"""
import os
import xlrd
import xlwt
import numpy
from collections import deque, OrderedDict


class XlsConverter():
  """
  This converter class convert JSON dictionary to XLS file with some
  specificity, it mostly use in Nuclear Imaging - Axon toolbox.
  For XLS files generated by it, this class could reverse operation to
  get back JSON dictionary
  """
  def __init__(self, separator=';', interpret_boolean_values=False):
    self.separator = ';'
    self.interpret_boolean_values = interpret_boolean_values
    self.sheet_dict_deque = deque()

    self.column_header_cell_style = xlwt.easyxf(
        "align: wrap on, vert centre, horiz center;")
    self.row_header_cell_style = xlwt.easyxf(
        "pattern: pattern solid, fore_colour gray25;"
        "borders: top_color white, bottom_color white, right_color white, left_color white, "
                  "left thin, right thin, top thin, bottom thin;"
        "align: wrap on, vert centre, horiz center;")
    self.data_cell_style = xlwt.easyxf(
        "align: wrap on, vert centre, horiz center")
    self.boolean_true_data_cell_style = xlwt.easyxf(
        "pattern: pattern solid, fore_colour green;"
        "font: colour green;"
        "align: wrap on, vert centre, horiz center")
    self.boolean_false_data_cell_style = xlwt.easyxf(
        "pattern: pattern solid, fore_colour red;"
        "font: colour red;"
        "align: wrap on, vert centre, horiz center")

  def addDictToConvert(self, sheet_dict):
    """
    pydict =
    {
    "sheet_name":"",
    "row_header":"",#each column name separated by separator
    "column_values":{},
    }
    """
    self.sheet_dict_deque.append(sheet_dict)

  def run(self, xls_path):
    """
    Convert all dict in memory to xls file
    """
    if not self.sheet_dict_deque:
      raise ValueError("At least one sheet_dict is required")
    else:
      book = xlwt.Workbook(style_compression=2)
      for sheet_dict in self.sheet_dict_deque:
        sheet = book.add_sheet(sheet_dict["sheet_name"])
        column_values_dict = sheet_dict["column_values"]
        max_header_level = self._extractHowManyHeaderLevelAtMaximum(column_values_dict)
        if max_header_level == 0:
          continue
          print("no data found for %s" % sheet_dict["sheet_name"])
        else:
          end_header_row_index = max_header_level - 1
          self._writeRowHeader(sheet, sheet_dict["row_header"], end_header_row_index)
          header_dict = OrderedDict()
          column_header_dict = self._extractHeaderDict(column_values_dict, header_dict)
          self._writeColumnHeader(sheet, sheet_dict["row_header"], column_header_dict, end_header_row_index)
          self._writeData(sheet, column_values_dict, column_header_dict, end_header_row_index)


      if not os.path.exists(os.path.dirname(xls_path)):
        os.makedirs(os.path.dirname(xls_path))
      book.save(xls_path)
      self.sheet_dict_deque.clear()

  def clearDictInMemory(self):
    """
    clear all dict in memory
    """
    self.sheet_dict_deque.clear()

  def _extractHowManyHeaderLevelAtMaximum(self, column_values_dict, current_level=-1, max_level=0):
    """
    current_level=-1, because first key is not header is row_ID
    """
    if isinstance(column_values_dict, dict):
      for value in column_values_dict.values():
        max_level_found = self._extractHowManyHeaderLevelAtMaximum(value, current_level+1, max_level)
        if max_level_found > max_level:
          max_level = max_level_found
      return max_level
    else:
      return current_level

  def _writeRowHeader(self, sheet, row_header, end_header_row_index):
    """
    write header above row id specify by keys from column_values
    """
    header_list = row_header.split(self.separator)
    for column_index, header_name in enumerate(header_list):
      sheet.merge(0, end_header_row_index, column_index, column_index)
      sheet.write(0, column_index, header_name, self.column_header_cell_style)

  def _extractHeaderDict(self, column_values_dict, header_dict, first_key=True):
    """
    extract all keys in value dict from column_values
    """
    for key, value in column_values_dict.items():
      if first_key:
        header_dict = XlsConverter.mergeDict(header_dict,
                                             self._extractHeaderDict(value,
                                                                     header_dict,
                                                                     False),
                                             d2_erase_d1=True)
      elif isinstance(value, dict):
        if not key in header_dict.keys():
          header_dict[key] = OrderedDict()
        header_dict[key] = XlsConverter.mergeDict(header_dict[key],
                                                  self._extractHeaderDict(value,
                                                                          header_dict[key],
                                                                          False),
                                                  d2_erase_d1=True)

      else:
        if not key in header_dict.keys():
          header_dict[key] = None
        pass
    return header_dict

  def _writeColumnHeader(self, sheet, row_header, column_header_dict, end_header_row_index):
    """
    write header above data in final value from column_values
    """
    current_column_index = len(row_header.split(self.separator))
    self._completeColumnHeader(sheet, end_header_row_index, column_header_dict, 0, current_column_index)

  def _completeColumnHeader(self, sheet, end_header_row_index, header_dict, current_row_index, current_column_index):
    for header_title, value in header_dict.items():
      if value is not None:
        sheet.merge(current_row_index, current_row_index, current_column_index, current_column_index+self._countLeaves(value)-1)
        sheet.write(current_row_index, current_column_index, header_title, self.column_header_cell_style)
        self._completeColumnHeader(sheet, end_header_row_index, value, current_row_index+1, current_column_index)
        current_column_index += self._countLeaves(value)
      else:
        sheet.merge(current_row_index, end_header_row_index, current_column_index, current_column_index)
        sheet.write(current_row_index, current_column_index, header_title, self.column_header_cell_style)
        current_column_index += 1

  def _countLeaves(self, pydict, leaves=0):
    """
    count how many key levels are in pydict
    """
    for key, value in pydict.items():
      leaves += 1
      if isinstance(value, dict):
        leaves = self._countLeaves(value, leaves-1)
      else:
        pass
    return leaves

  def _writeData(self, sheet, column_values_dict, column_header_dict, end_header_row_index):
    """
    write data below headers
    """
    current_row_index = end_header_row_index+1
    for row, row_dict in sorted(column_values_dict.items()):
      row_header_list = row.split(self.separator)
      for current_column_index, row_header in enumerate(row_header_list):
        sheet.write(current_row_index, current_column_index, row_header, self.row_header_cell_style)
      self._writeRowData(sheet, row_dict, column_header_dict, current_row_index, current_column_index+1)
      current_row_index += 1

  def _writeRowData(self, sheet, row_dict, column_header_dict, current_row_index, current_column_index):
    for key, value in sorted(column_header_dict.items()):
      if key in row_dict.keys():
        if isinstance(value, dict):
          current_column_index = self._writeRowData(sheet, row_dict[key], column_header_dict[key], current_row_index, current_column_index)
        else:
          if isinstance(row_dict[key], bool) and self.interpret_boolean_values:
            if row_dict[key]:
              sheet.write(current_row_index, current_column_index, str(row_dict[key]), self.boolean_true_data_cell_style)
            else:
              sheet.write(current_row_index, current_column_index, str(row_dict[key]), self.boolean_false_data_cell_style)
          else:
            sheet.write(current_row_index, current_column_index, row_dict[key], self.data_cell_style)
          current_column_index += 1
      else:
        if isinstance(value, dict):
          current_column_index += self._countLeaves(value)
        else:
          current_column_index += 1
    return current_column_index
#==============================================================================
#
#==============================================================================
  def reverse(self, xls_path):
    """
    this method recompute sheet_dict list from xls created by it
    """
    sheet_dict_deque = deque()
    workbook = xlrd.open_workbook(xls_path, formatting_info=True)
    sheet_names = workbook.sheet_names()
    for sheet_name in sheet_names:
      sheet_dict = OrderedDict()
      sheet = workbook.sheet_by_name(sheet_name)
      sheet_dict["sheet_name"] = sheet.name
      sheet_dict["row_header"] = self._getRowHeaderFromSheet(sheet, workbook)
      sheet_dict["column_values"] = self._getColumnValuesFromSheet(sheet, workbook)
      sheet_dict_deque.append(sheet_dict)
    return sheet_dict_deque

  def _getRowHeaderFromSheet(self, sheet, workbook):
    """
    first row contains header and second is empty, if it is not the case it will do not work
    """
    row_header_list = []
    first_row_data_index, first_column_data_index = self._getFirstCellIndexWithData(sheet, workbook)
    for column_index in range(first_column_data_index):
        row_header_list.append(sheet.cell_value(0, column_index))
    return self.separator.join(row_header_list)

  def _getColumnValuesFromSheet(self, sheet, workbook):
    """
    extract each row value with all column header above
    """
    first_row_data_index, first_column_data_index = self._getFirstCellIndexWithData(sheet, workbook)
    header_tempalte_dict = self._createHeaderTemplate(sheet, first_row_data_index, first_column_data_index)
    row_data_index = first_row_data_index
    column_values_dict = OrderedDict()
    while(row_data_index <= self._getLastRowWithData(sheet)):
      row_id = self._getRowId(sheet, row_data_index, first_column_data_index)
      column_values_dict[row_id] = self._getValues(sheet, row_data_index, header_tempalte_dict)
      row_data_index += 1
    return column_values_dict

  def _getFirstCellIndexWithData(self, sheet, workbook):
    """
    extract position of first cell wich is not header,
    based on xf_index.
    **requirement : (column_header and row_header) and (data and row_header)
    must have different background pattern_colour_index
    column_header and data can have the same
    """
    #iterate row until background change => first row_header index (first data_row index)
    column_header_background_pattern_colour_index = workbook.xf_list[sheet.cell_xf_index(0,0)].background.pattern_colour_index
    row_index = 1
    current_background_pattern_colour_index = workbook.xf_list[sheet.cell_xf_index(row_index,0)].background.pattern_colour_index
    while(current_background_pattern_colour_index == column_header_background_pattern_colour_index):
        row_index += 1
        current_background_pattern_colour_index = workbook.xf_list[sheet.cell_xf_index(row_index,0)].background.pattern_colour_index
    row_header_background_pattern_colour_index = current_background_pattern_colour_index
    #iterate column until background change => first column_data index
    column_index = 1
    current_background_pattern_colour_index = workbook.xf_list[sheet.cell_xf_index(row_index,column_index)].background.pattern_colour_index
    while(row_header_background_pattern_colour_index == current_background_pattern_colour_index) :
        column_index += 1
        current_background_pattern_colour_index = workbook.xf_list[sheet.cell_xf_index(row_index,column_index)].background.pattern_colour_index
    return row_index, column_index


  def _getRowId(self, sheet, row_data_index, first_column_data_index):
    """
    get and join all cells about row_id
    """
    row_id_list = []
    for column_index in range(first_column_data_index):
      row_id_list.append(str(sheet.cell_value(row_data_index,column_index )))
    return self.separator.join(row_id_list)

  def _getValues(self, sheet, row_data_index, header_template_dict):
    """
    extract row value with all column header above
    """
    values_dict = OrderedDict()
    for column_index, header_list in header_template_dict.items():
      val = sheet.cell_value(row_data_index, column_index)
      if val:
          current_col_dict = self._buildCompleteBranchDict(header_list, val)
          values_dict = XlsConverter.mergeDict(values_dict, current_col_dict)
    return values_dict

  def _createHeaderTemplate(self, sheet, first_row_data_index, first_data_column_index):
    """
    create dict with all header hierarchy and column_index in leaves
    """
    header_template_dict = OrderedDict()
    column_index = first_data_column_index
    while(column_index <= self._getLastColumnWithData(sheet)):
      row_index = 0
      header_list = []
      while (row_index < first_row_data_index):
        header_name, row_index = self._getHeaderCellValue(sheet, row_index, column_index)
        header_list.append(header_name)
        row_index += 1
      header_template_dict[column_index] = header_list
      column_index += 1
    return header_template_dict


  def _buildCompleteBranchDict(self, header_list, last_value):
    if numpy.isnan(last_value):
      last_value = "'NaN'"
    str_dict = "{u'%s':%s}" % ("':{u'".join(header_list), last_value)
    str_dict += '}'*(len(header_list)-1)
    return eval(str_dict)

  def _getHeaderCellValue(self, sheet, row_index, column_index):
    """
    method use to return header value even if cell is merged
    """
    if not self._isEmptyCell(sheet, row_index, column_index):  # merged cell is empty, it is not the left upper corner cell
      return sheet.cell_value(row_index, column_index), row_index
    else:  # check if cell is merged
      for r_min, r_max, c_min, c_max in sheet.merged_cells:
        if row_index >= r_min and row_index <= r_max and column_index >= c_min and column_index <= c_max:
          return sheet.cell_value(r_min, c_min), r_max-1
    raise ValueError("empty cell is actually forbidden in column header")

  def _getLastColumnWithData(self, sheet):
    """
    some soft as libreoffice add empty columns when user modify xls by hand
    """
    last_column_index = sheet.ncols -1
    while(list(set(sheet.col_values(last_column_index))) == ['']):
        last_column_index -= 1
    return last_column_index

  def _getLastRowWithData(self, sheet) :
    """
    some soft as libreoffice add empty rows when user modify xls by hand
    """
    last_row_index = sheet.nrows -1
    while(list(set(sheet.row_values(last_row_index))) == ['']):
        last_row_index -= 1
    return last_row_index

  def _isEmptyCell(self, sheet, row_index, column_index):
      return sheet.cell_type(row_index, column_index) in (xlrd.XL_CELL_EMPTY, xlrd.XL_CELL_BLANK)
#==============================================================================
# Static method
#==============================================================================
  @staticmethod
  def mergeDict(d1, d2, d2_erase_d1=False ):
    """This method allow to merge two python dictionaries
    without erase the deep keys, contrary to classical "update" method"""
    dict_merged = OrderedDict()
    key_list = []
    key_set = set()
    key_list.extend( d1.keys() )
    key_list.extend( d2.keys() )
    key_list = [k for k in key_list if not (k in key_set or key_set.add(k))]
    for key in key_list:
      if isinstance( key, str ):
        new_key = key.replace( '\n', '' )
      else:
        new_key = key
      if key in d1.keys() and key in d2.keys():
        if isinstance( d1[key], dict ) and isinstance( d2[key], dict ):
          dict_merged[new_key] = XlsConverter.mergeDict( d1[key], d2[key], d2_erase_d1 )
        else:
          # If same data are merged, neither d1 value nor d2 value was wrote
          if d2_erase_d1:
            dict_merged[new_key] = d2[key]
          else:
            dict_merged[new_key] = '** data merged **'
      elif key in d1.keys() and not key in d2.keys():
        dict_merged[new_key] = d1[key]
      elif not key in d1.keys() and key in d2.keys():
        dict_merged[new_key] = d2[key]
    return dict_merged
